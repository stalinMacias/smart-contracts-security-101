// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

import "@openzeppelin/contracts-release-v4.5/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/Address.sol";

//@Preventative Techniques -> Sign messages with nonce and address of the contract.

contract MultiSigWalletV2 {
    using ECDSA for bytes32;
    using Address for address payable;

    address[2] public owners;

    mapping(bytes32 => bool) public executed;

    constructor(address[2] memory _owners) payable {
        owners = _owners;
    }

    // address _to & uint _amount combined are the original message that the signers are signing
    // uint nonce is the variable that is used to add an uniqueness value to each signature
    
    // The txHash will be the same for the two owners, what will be different is the signature generated by them
    // Is a must to send the _sigs array in order, starting from the first owner and then the second owner
    function transfer(address _to, uint _amount, bytes[2] memory _sigs, uint nonce) external {
      // Validate that the signatures have not been executed
      for (uint i = 0; i < _sigs.length; i++) {
        require(!executed[bytes32(_sigs[i])], "Signature has already been executed");
      }

      // Get the hash of the original message
      bytes32 txHash = getTxHash(address(this), _to, _amount, nonce);

      require(_checkSigs(_sigs, txHash), "Invalid Signature");

      // Setting as executed the signatures
      for (uint i = 0; i < _sigs.length; i++) {
        executed[bytes32(_sigs[i])] = true;
      }

      payable(_to).sendValue(_amount);
    }
    function getTxHash(address contractAddres, address _to, uint _amount, uint nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(contractAddres, _to, _amount, nonce));
    }

    function _checkSigs(
        bytes[2] memory _sigs,
        bytes32 _txHash
    ) private view returns (bool) {
        // Get the hash of the EthSignedMessage -> The actual hash that was used with the private keys to generate the signaure
        // 	When you use web3/ethersJS to sign a message hash, you are actually signing:
		        // https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
		        // JSON-RPC method as part of EIP-191.
                // keccak256("\x19Ethereum Signed Message:\n32", message hash)
        bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();

        for (uint i = 0; i < _sigs.length; i++) {
            address signer = ethSignedHash.recover(_sigs[i]);
            bool valid = signer == owners[i];

            if (!valid) {
                return false;
            }
        }

        return true;
    }

    function getExecutedTransactions(bytes memory _sig) public view returns (bool) {
      return executed[bytes32(_sig)];
    }

    receive() external payable {}

}